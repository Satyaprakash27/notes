<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAPI Miscellaneous Topics - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background: #0d1117;
            min-height: 100vh;
            margin: 0;
            display: flex;
        }

        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            overflow-y: auto;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: #34495e;
            border-bottom: 1px solid #455a75;
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 1.3em;
            color: #ecf0f1;
            border: none;
            padding: 0;
        }

        .sidebar-header h2 a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 5px 0;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .sidebar-header h2 a:hover {
            color: #3498db;
            background: rgba(52, 152, 219, 0.1);
            transform: translateX(2px);
        }

        .sidebar-nav {
            padding: 0;
        }

        .sidebar-section {
            border-bottom: 1px solid #455a75;
        }

        .sidebar-section-title {
            background: #34495e;
            color: #ecf0f1;
            padding: 15px 20px;
            margin: 0;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-section-title:hover {
            background: #455a75;
        }

        .sidebar-links {
            background: #2c3e50;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .sidebar-section.active .sidebar-links {
            max-height: 500px;
        }

        .sidebar-links a {
            display: block;
            color: #bdc3c7;
            text-decoration: none;
            padding: 12px 25px;
            border-bottom: 1px solid #34495e;
            transition: background 0.2s ease;
        }

        .sidebar-links a:hover {
            background: #34495e;
            color: #ecf0f1;
        }

        .sidebar-links a.current {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .main-content {
            margin-left: 280px;
            flex: 1;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #161b22;
            min-height: 100vh;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
            border: 1px solid #30363d;
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .main-content {
                margin-left: 0;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .toc {
            background: #161b22;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #58a6ff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid #30363d;
        }

        .toc h2 {
            color: #58a6ff;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 8px 0;
        }

        .toc a {
            color: #e6edf3;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: block;
        }

        .toc a:hover {
            background: #58a6ff;
            color: white;
            transform: translateX(10px);
        }

        .section {
            margin-bottom: 50px;
            background: #1c2128;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            border-left: 5px solid #238636;
            border: 1px solid #30363d;
        }

        .section h2 {
            color: #238636;
            font-size: 2.2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #238636;
        }

        .section h3 {
            color: #58a6ff;
            font-size: 1.6em;
            margin: 25px 0 15px 0;
            padding-left: 15px;
            border-left: 3px solid #58a6ff;
        }

        .section h4 {
            color: #e6edf3;
            font-size: 1.3em;
            margin: 20px 0 10px 0;
        }

        .section p {
            margin-bottom: 15px;
            color: #e6edf3;
            font-size: 1.1em;
        }

        .section ul, .section ol {
            margin: 15px 0 15px 30px;
            color: #e6edf3;
        }

        .section li {
            margin: 8px 0;
            font-size: 1.05em;
        }

        .code-container {
            position: relative;
            margin: 20px 0;
            background: #2d3748;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .code-header {
            background: #1a202c;
            color: #e2e8f0;
            padding: 12px 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #4a5568;
        }

        .language-label {
            color: #68d391;
            font-size: 0.9em;
        }

        .copy-button {
            background: #238636;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .copy-button:hover {
            background: #2ea043;
            transform: scale(1.05);
        }

        .copy-button:active {
            background: #2ea043;
            transform: scale(0.95);
        }

        pre {
            margin: 0;
            padding: 20px;
            background: #2d3748;
            color: #e2e8f0;
            overflow-x: auto;
            font-family: 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .keyword { color: #f093cc; }
        .string { color: #a8e6cf; }
        .comment { color: #718096; font-style: italic; }
        .function { color: #90cdf4; }
        .number { color: #fbb6ce; }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #161b22;
        }

        th {
            background: #58a6ff;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #30363d;
            color: #e6edf3;
        }

        tr:nth-child(even) {
            background: #1c2128;
        }

        tr:hover {
            background: #21262d;
            transition: background 0.3s ease;
        }

        .highlight {
            background: #1c2128;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #238636;
            border: 1px solid #30363d;
        }

        .warning {
            background: #1c2128;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #f85149;
            border: 1px solid #30363d;
        }

        .info {
            background: #1c2128;
            color: #e6edf3;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #58a6ff;
            border: 1px solid #30363d;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #58a6ff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .back-to-top.visible {
            opacity: 1;
            visibility: visible;
        }

        .back-to-top:hover {
            background: #1f6feb;
            transform: translateY(-5px);
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .section h2 {
                font-size: 1.8em;
            }

            pre {
                font-size: 0.85em;
                padding: 15px;
            }

            .code-header {
                padding: 10px 15px;
            }
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            padding: 30px;
            background: #1c2128;
            color: white;
            border-radius: 15px;
            border: 1px solid #30363d;
        }        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #58a6ff, #238636);
            z-index: 1000;
            transition: width 0.3s ease;
        }

        .nav {
            background: #1c2128;
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            position: sticky;
            top: 20px;
            z-index: 100;
            border: 1px solid #30363d;
            backdrop-filter: blur(10px);
        }

        .nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
        }

        .nav a {
            color: #58a6ff;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            transition: all 0.3s ease;
            font-weight: 500;
            border: 1px solid transparent;
        }

        .nav a:hover, .nav a.active {
            background: linear-gradient(45deg, #1f6feb, #8b5cf6);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(31, 111, 235, 0.4);
            border-color: #1f6feb;
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
            scroll-padding-top: 120px; /* Account for sticky nav */
        }

        /* Highlight target section */
        :target {
            background-color: #21262d;
            padding: 15px;
            border-radius: 8px;
            margin: -15px;
            animation: highlight 2s ease-in-out;
        }

        @keyframes highlight {
            0% { background-color: #58a6ff; }
            100% { background-color: #21262d; }
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" onclick="toggleSidebar()">☰</button>
      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2><a href="../../Python.html" style="color: #ecf0f1; text-decoration: none;">🐍 Python Guides</a></h2>
        </div>
        <nav class="sidebar-nav">
            <div class="sidebar-section">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    🐍 Basic Python <span>▶</span>
                </div>
                <div class="sidebar-links">
                    <a href="../../1.Basic Python/basic-python-guide.html">Python Fundamentals</a>
                    <a href="../../1.Basic Python/1.Python Concepts/python-concepts.html">Core Concepts</a>
                    <a href="../../1.Basic Python/2.Data Structures/python-data-structures.html">Data Structures</a>
                    <a href="../../1.Basic Python/3.Algorithms & Problem Solving/algorithms-problem-solving.html">Algorithms & Problem Solving</a>
                    <a href="../../1.Basic Python/4.Testing & Debugging/testing-debugging.html">Testing & Debugging</a>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    ⚡ Async Programming <span>▶</span>
                </div>
                <div class="sidebar-links">
                    <a href="../../2.Async Programming/async-programming-guide.html">Asyncio & Concurrency</a>
                </div>
            </div>
            <div class="sidebar-section active">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    🚀 FastAPI <span>▼</span>
                </div>
                <div class="sidebar-links">
                    <a href="../fastapi-guide.html">FastAPI Overview</a>
                    <a href="../1.Basic/fastapi-basics-complete.html">FastAPI Fundamentals</a>
                    <a href="../2.API Development/api-development-guide.html">API Development</a>
                    <a href="../3.Security/security-guide.html">Security & Authentication</a>
                    <a href="../4.Testing/testing-guide.html">Testing Strategies</a>
                    <a href="../5.Advanced Topics/advanced-topics-guide.html">Advanced Topics</a>
                    <a href="../6.Miscellaneous/miscellaneous-guide.html" class="current">Tips & Best Practices</a>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    🦜 LangChain <span>▶</span>
                </div>
                <div class="sidebar-links">
                    <a href="../../4.LangChain/langchain-documentation.html">LangChain Framework</a>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    📊 LangGraph <span>▶</span>
                </div>
                <div class="sidebar-links">
                    <a href="../../5.LangGraph/langgraph-guide.html">Graph-based AI</a>
                </div>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-section-title" onclick="toggleSection(this)">
                    🤖 Agentic AI <span>▶</span>
                </div>
                <div class="sidebar-links">
                    <a href="../../7.Agentic AI/agentic-ai-guide.html">AI Agents Guide</a>
                </div>
            </div>
        </nav>
    </div>

    <div class="main-content">
        <div class="progress-bar" id="progressBar"></div>
        
        <div class="container">
        <div class="header">
            <h1>🔧 FastAPI Miscellaneous Topics</h1>
            <p>Advanced concepts and utilities for FastAPI development</p>
        </div>        <nav class="nav">
            <ul>
                <li><a href="#openapi-generation" class="nav-link">🔄 OpenAPI Docs</a></li>
                <li><a href="#depends-vs-middleware" class="nav-link">⚡ Depends vs Middleware</a></li>
                <li><a href="#response-model" class="nav-link">📤 Response Models</a></li>
                <li><a href="#depends-security" class="nav-link">🔐 Security Utils</a></li>
                <li><a href="#streaming-responses" class="nav-link">🌊 Streaming</a></li>
            </ul>
        </nav>

        <section class="section" id="openapi-generation">
            <h2>✅ How does FastAPI generate OpenAPI and Swagger docs?</h2>
            
            <p>FastAPI automatically generates OpenAPI (formerly Swagger) documentation based on your code, type hints, and Pydantic models. This happens through introspection of your endpoints, models, and metadata.</p>

            <h3>Automatic Documentation Generation</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional

app = FastAPI(
    title="My API",
    description="A sample API with automatic documentation",
    version="1.0.0",
    terms_of_service="http://example.com/terms/",
    contact={
        "name": "API Support",
        "url": "http://www.example.com/contact/",
        "email": "support@example.com",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    },
)

class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None

@app.post("/items/", tags=["items"], summary="Create an item")
async def create_item(item: Item):
    """
    Create an item with all the information:
    
    - **name**: each item must have a name
    - **description**: a long description
    - **price**: required
    - **tax**: if the item doesn't have tax, you can omit this
    """
    return item

@app.get("/items/{item_id}", tags=["items"])
async def read_item(item_id: int, q: Optional[str] = None):
    """Get an item by ID"""
    return {"item_id": item_id, "q": q}</code></pre>
            </div>

            <h3>Customizing OpenAPI Schema</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI, Query, Path
from fastapi.openapi.utils import get_openapi
from fastapi.openapi.docs import get_swagger_ui_html

app = FastAPI()

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title="Custom API",
        version="2.5.0",
        description="This is a very custom OpenAPI schema",
        routes=app.routes,
    )
    
    # Add custom extensions
    openapi_schema["info"]["x-logo"] = {
        "url": "https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png"
    }
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

@app.get("/items/{item_id}")
async def read_item(
    item_id: int = Path(..., title="The ID of the item", ge=1, le=1000),
    q: str = Query(None, min_length=3, max_length=50, regex="^[a-zA-Z ]+$")
):
    return {"item_id": item_id, "q": q}

# Custom docs endpoint
@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - Swagger UI",
        oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        swagger_js_url="/static/swagger-ui-bundle.js",
        swagger_css_url="/static/swagger-ui.css",
    )</code></pre>
            </div>

            <h3>Advanced OpenAPI Customization</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI, status
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field

app = FastAPI()

class ErrorResponse(BaseModel):
    detail: str
    error_code: int

class ItemResponse(BaseModel):
    id: int = Field(..., description="The item ID")
    name: str = Field(..., description="The item name", example="Laptop")
    price: float = Field(..., description="Price in USD", example=999.99)

@app.post(
    "/items/",
    response_model=ItemResponse,
    status_code=status.HTTP_201_CREATED,
    responses={
        201: {
            "description": "Item created successfully",
            "content": {
                "application/json": {
                    "example": {"id": 1, "name": "Laptop", "price": 999.99}
                }
            }
        },
        422: {
            "description": "Validation Error",
            "model": ErrorResponse,
            "content": {
                "application/json": {
                    "example": {"detail": "Invalid input", "error_code": 4001}
                }
            }
        }
    },
    operation_id="create_item_endpoint"
)
async def create_item(item: dict):
    """Create a new item in the system"""
    return ItemResponse(id=1, name=item["name"], price=item["price"])</code></pre>
            </div>
        </section>

        <section class="section" id="depends-vs-middleware">
            <h2>✅ What is the difference between Depends and middleware?</h2>
            
            <p><strong>Depends</strong> and <strong>middleware</strong> serve different purposes in FastAPI and operate at different levels of the request lifecycle.</p>

            <h3>Depends (Dependency Injection)</h3>
            
            <p>Depends is used for dependency injection at the endpoint level. It's executed per endpoint and can be used for specific route requirements.</p>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI, Depends, HTTPException
from typing import Optional

app = FastAPI()

# Database dependency
def get_db():
    db = {"connection": "active"}
    try:
        yield db
    finally:
        print("Closing database connection")

# Authentication dependency
def get_current_user(token: str = None):
    if not token:
        raise HTTPException(status_code=401, detail="Token required")
    return {"user_id": 1, "username": "john_doe"}

# Authorization dependency
def require_admin(current_user: dict = Depends(get_current_user)):
    if current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin required")
    return current_user

# Endpoint-specific dependencies
@app.get("/users/")
async def get_users(
    db: dict = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    return {"users": [], "requested_by": current_user["username"]}

@app.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    admin_user: dict = Depends(require_admin),
    db: dict = Depends(get_db)
):
    return {"message": f"User {user_id} deleted by {admin_user['username']}"}

# Sub-dependencies
def get_pagination(skip: int = 0, limit: int = 100):
    return {"skip": skip, "limit": limit}

def get_filtered_items(
    db: dict = Depends(get_db),
    pagination: dict = Depends(get_pagination)
):
    return {
        "items": ["item1", "item2"],
        "pagination": pagination
    }

@app.get("/items/")
async def list_items(items: dict = Depends(get_filtered_items)):
    return items</code></pre>
            </div>

            <h3>Middleware (Global Request Processing)</h3>
            
            <p>Middleware operates at the application level and processes every request/response globally.</p>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>import time
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()

# Timing middleware
class TimingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers["X-Process-Time"] = str(process_time)
        return response

# Logging middleware
class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        print(f"Request: {request.method} {request.url}")
        response = await call_next(request)
        print(f"Response: {response.status_code}")
        return response

# Security headers middleware
class SecurityMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        return response

# Add middleware (order matters - last added executes first)
app.add_middleware(TimingMiddleware)
app.add_middleware(LoggingMiddleware)
app.add_middleware(SecurityMiddleware)

@app.get("/")
async def root():
    return {"message": "Hello World"}</code></pre>
            </div>

            <h3>Key Differences Summary</h3>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Depends</th>
                            <th>Middleware</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Endpoint-specific</td>
                            <td>Application-wide</td>
                        </tr>
                        <tr>
                            <td><strong>Execution</strong></td>
                            <td>Per-dependency, per-endpoint</td>
                            <td>Every request/response</td>
                        </tr>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Dependency injection, validation</td>
                            <td>Request/response processing</td>
                        </tr>
                        <tr>
                            <td><strong>Flexibility</strong></td>
                            <td>Conditional based on endpoint</td>
                            <td>Global for all requests</td>
                        </tr>
                        <tr>
                            <td><strong>Error Handling</strong></td>
                            <td>Can raise HTTPExceptions</td>
                            <td>Must handle errors carefully</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Only when dependency is used</td>
                            <td>Every request</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section class="section" id="response-model">
            <h2>✅ What is the role of ResponseModel in FastAPI?</h2>
            
            <p>ResponseModel (specified as <code>response_model</code>) defines the structure and validation of API responses. It serves multiple purposes in FastAPI applications.</p>

            <h3>Basic Response Model Usage</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: str
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str

class UserResponse(UserBase):
    id: int
    is_active: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

# Database simulation
fake_users_db = [
    {
        "id": 1,
        "username": "john_doe",
        "email": "john@example.com",
        "full_name": "John Doe",
        "password": "secret123",
        "is_active": True,
        "created_at": datetime.now()
    }
]

@app.post("/users/", response_model=UserResponse)
async def create_user(user: UserCreate):
    # Password won't be included in response due to response_model
    db_user = {**user.dict(), "id": len(fake_users_db) + 1, 
               "is_active": True, "created_at": datetime.now()}
    fake_users_db.append(db_user)
    return db_user

@app.get("/users/", response_model=List[UserResponse])
async def get_users():
    return fake_users_db

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(user_id: int):
    user = next((u for u in fake_users_db if u["id"] == user_id), None)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user</code></pre>
            </div>

            <h3>Advanced Response Model Features</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from pydantic import BaseModel, validator
from typing import Union
from enum import Enum

class StatusEnum(str, Enum):
    success = "success"
    error = "error"
    pending = "pending"

class BaseResponse(BaseModel):
    status: StatusEnum
    message: str
    timestamp: datetime = Field(default_factory=datetime.now)

class DataResponse(BaseResponse):
    data: dict

class ErrorResponse(BaseResponse):
    error_code: int
    details: Optional[str] = None

class PaginatedResponse(BaseModel):
    items: List[dict]
    total: int
    page: int
    size: int
    has_next: bool
    
    @validator('has_next', always=True)
    def calculate_has_next(cls, v, values):
        if 'total' in values and 'page' in values and 'size' in values:
            return (values['page'] * values['size']) < values['total']
        return False

# Multiple response models for different status codes
@app.get(
    "/data/{item_id}",
    response_model=Union[DataResponse, ErrorResponse],
    responses={
        200: {"model": DataResponse, "description": "Success response"},
        404: {"model": ErrorResponse, "description": "Item not found"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
async def get_data(item_id: int):
    if item_id == 404:
        return ErrorResponse(
            status=StatusEnum.error,
            message="Item not found",
            error_code=404,
            details=f"No item found with ID {item_id}"
        )
    
    return DataResponse(
        status=StatusEnum.success,
        message="Data retrieved successfully",
        data={"item_id": item_id, "name": "Sample Item"}
    )</code></pre>
            </div>
        </section>

        <section class="section" id="depends-security">
            <h2>✅ What is the use of Depends and Security utilities?</h2>
            
            <p>Depends and Security utilities in FastAPI provide powerful dependency injection capabilities for handling authentication, authorization, and other cross-cutting concerns.</p>

            <h3>Basic Depends Usage</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

app = FastAPI()
security = HTTPBearer()

# Configuration dependency
def get_settings():
    return {
        "database_url": "postgresql://localhost/mydb",
        "secret_key": "your-secret-key",
        "algorithm": "HS256"
    }

# Database dependency
def get_database_connection(settings: dict = Depends(get_settings)):
    # Simulate database connection
    return {"connection": f"Connected to {settings['database_url']}"}

# Authentication dependency
def verify_token(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    settings: dict = Depends(get_settings)
):
    try:
        payload = jwt.decode(
            credentials.credentials,
            settings["secret_key"],
            algorithms=[settings["algorithm"]]
        )
        username = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
        return {"username": username, "token": credentials.credentials}
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

# Role-based authorization dependency
def require_role(required_role: str):
    def role_dependency(current_user: dict = Depends(verify_token)):
        # In real app, you'd get user roles from database
        user_roles = ["user", "admin"]  # Mock user roles
        if required_role not in user_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Role {required_role} required"
            )
        return current_user
    return role_dependency

@app.get("/profile")
async def get_profile(current_user: dict = Depends(verify_token)):
    return {"username": current_user["username"]}

@app.get("/admin")
async def admin_only(admin_user: dict = Depends(require_role("admin"))):
    return {"message": "Welcome admin!", "user": admin_user["username"]}</code></pre>
            </div>

            <h3>Security Utilities</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI, Depends, HTTPException, status, Form
from fastapi.security import (
    HTTPBasic, HTTPBasicCredentials,
    HTTPBearer, HTTPAuthorizationCredentials,
    OAuth2PasswordBearer, OAuth2PasswordRequestForm,
    APIKeyHeader, APIKeyQuery, APIKeyCookie
)
import secrets
import hashlib

app = FastAPI()

# HTTP Basic Authentication
security_basic = HTTPBasic()

def verify_basic_auth(credentials: HTTPBasicCredentials = Depends(security_basic)):
    correct_username = secrets.compare_digest(credentials.username, "admin")
    correct_password = secrets.compare_digest(credentials.password, "secret")
    if not (correct_username and correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username

# Bearer Token Authentication
security_bearer = HTTPBearer()

def verify_bearer_token(credentials: HTTPAuthorizationCredentials = Depends(security_bearer)):
    if credentials.credentials != "valid-bearer-token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid bearer token"
        )
    return {"token": credentials.credentials}

# OAuth2 Password Bearer
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_oauth_token(token: str = Depends(oauth2_scheme)):
    # Verify JWT token here
    if token != "valid-oauth-token":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid OAuth token"
        )
    return {"token": token}

# API Key Authentication
api_key_header = APIKeyHeader(name="X-API-Key")
api_key_query = APIKeyQuery(name="api_key")
api_key_cookie = APIKeyCookie(name="api_key")

def verify_api_key(api_key: str = Depends(api_key_header)):
    if api_key != "valid-api-key":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    return {"api_key": api_key}

# Multiple authentication methods
def verify_api_key_flexible(
    header_key: str = Depends(api_key_header),
    query_key: str = Depends(api_key_query),
    cookie_key: str = Depends(api_key_cookie)
):
    valid_key = "valid-api-key"
    if header_key == valid_key or query_key == valid_key or cookie_key == valid_key:
        return {"authenticated": True}
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid API key"
    )

# Endpoints using different auth methods
@app.get("/basic-auth")
async def basic_auth_endpoint(username: str = Depends(verify_basic_auth)):
    return {"message": f"Hello {username}!"}

@app.get("/bearer-auth")
async def bearer_auth_endpoint(token_data: dict = Depends(verify_bearer_token)):
    return {"message": "Authenticated with bearer token", "token": token_data["token"]}

@app.get("/oauth-auth")
async def oauth_auth_endpoint(token_data: dict = Depends(verify_oauth_token)):
    return {"message": "Authenticated with OAuth", "token": token_data["token"]}

@app.get("/api-key-auth")
async def api_key_auth_endpoint(api_data: dict = Depends(verify_api_key)):
    return {"message": "Authenticated with API key"}</code></pre>
            </div>

            <h3>Advanced Dependency Patterns</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from functools import lru_cache
from typing import Generator, Optional

# Cached dependencies
@lru_cache()
def get_expensive_computation():
    # Expensive operation that should be cached
    print("Performing expensive computation...")
    return {"result": "computed_value"}

# Generator dependencies (with cleanup)
def get_db_session() -> Generator:
    session = create_db_session()
    try:
        yield session
    finally:
        session.close()

# Conditional dependencies
def get_user_service(use_cache: bool = True):
    if use_cache:
        return CachedUserService()
    return DatabaseUserService()

# Class-based dependencies
class UserService:
    def __init__(self, db_session=Depends(get_db_session)):
        self.db = db_session
    
    def get_user(self, user_id: int):
        return {"id": user_id, "name": "John Doe"}

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    user_service: UserService = Depends()
):
    return user_service.get_user(user_id)

# Global dependencies (applied to all routes)
app = FastAPI(dependencies=[Depends(verify_api_key)])</code></pre>
            </div>
        </section>

        <section class="section" id="streaming-responses">
            <h2>✅ How do you stream large responses in FastAPI?</h2>
            
            <p>Streaming responses in FastAPI is essential for handling large files, real-time data, or memory-efficient data transfer.</p>

            <h3>Basic File Streaming</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import FastAPI
from fastapi.responses import StreamingResponse, FileResponse
import io
import csv
from typing import Iterator
import os

app = FastAPI()

@app.get("/download-large-file")
async def download_large_file():
    def generate_large_csv():
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow(["id", "name", "email", "data"])
        yield output.getvalue()
        output.seek(0)
        output.truncate(0)
        
        # Generate large dataset
        for i in range(100000):
            writer.writerow([i, f"User {i}", f"user{i}@example.com", f"data_{i}"])
            if i % 1000 == 0:  # Yield every 1000 rows
                yield output.getvalue()
                output.seek(0)
                output.truncate(0)
        
        # Yield remaining data
        if output.tell():
            yield output.getvalue()

    return StreamingResponse(
        generate_large_csv(),
        media_type="text/csv",
        headers={"Content-Disposition": "attachment; filename=large_data.csv"}
    )

@app.get("/stream-file/{file_path}")
async def stream_file(file_path: str):
    def file_generator(file_path: str):
        with open(file_path, "rb") as file:
            while chunk := file.read(8192):  # Read in 8KB chunks
                yield chunk
    
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    
    return StreamingResponse(
        file_generator(file_path),
        media_type="application/octet-stream",
        headers={"Content-Disposition": f"attachment; filename={os.path.basename(file_path)}"}
    )</code></pre>
            </div>

            <h3>Streaming JSON Data</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>import json
from typing import AsyncGenerator

@app.get("/stream-json-array")
async def stream_json_array():
    async def generate_json_array():
        yield "["
        
        for i in range(10000):
            item = {
                "id": i,
                "name": f"Item {i}",
                "description": f"Description for item {i}",
                "data": [j for j in range(100)]  # Large data
            }
            
            if i > 0:
                yield ","
            yield json.dumps(item)
        
        yield "]"
    
    return StreamingResponse(
        generate_json_array(),
        media_type="application/json"
    )

@app.get("/stream-json-lines")
async def stream_json_lines():
    async def generate_json_lines():
        for i in range(10000):
            item = {
                "timestamp": datetime.now().isoformat(),
                "id": i,
                "data": f"Data point {i}"
            }
            yield json.dumps(item) + "\n"
    
    return StreamingResponse(
        generate_json_lines(),
        media_type="application/x-ndjson",
        headers={"Content-Disposition": "attachment; filename=data.jsonl"}
    )</code></pre>
            </div>

            <h3>Database Streaming</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from sqlalchemy.orm import Session
from sqlalchemy import text

@app.get("/stream-database-results")
async def stream_database_results(db: Session = Depends(get_db)):
    def stream_query_results():
        # Use server-side cursor for large datasets
        query = text("SELECT * FROM large_table ORDER BY id")
        result = db.execute(query)
        
        # Stream results in batches
        batch_size = 1000
        while True:
            rows = result.fetchmany(batch_size)
            if not rows:
                break
            
            for row in rows:
                yield json.dumps(dict(row)) + "\n"
    
    return StreamingResponse(
        stream_query_results(),
        media_type="application/x-ndjson"
    )

@app.get("/stream-paginated-data")
async def stream_paginated_data(db: Session = Depends(get_db)):
    async def generate_paginated_data():
        page = 0
        page_size = 100
        
        while True:
            offset = page * page_size
            query = db.query(User).offset(offset).limit(page_size)
            users = query.all()
            
            if not users:
                break
            
            for user in users:
                user_data = {
                    "id": user.id,
                    "username": user.username,
                    "email": user.email
                }
                yield json.dumps(user_data) + "\n"
            
            page += 1
    
    return StreamingResponse(
        generate_paginated_data(),
        media_type="application/x-ndjson"
    )</code></pre>
            </div>

            <h3>Server-Sent Events (SSE)</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>import asyncio
from sse_starlette.sse import EventSourceResponse

@app.get("/events")
async def stream_events():
    async def event_generator():
        counter = 0
        while True:
            # Check if client is still connected
            if await request.is_disconnected():
                break
            
            # Send event data
            data = {
                "timestamp": datetime.now().isoformat(),
                "counter": counter,
                "message": f"Event {counter}"
            }
            
            yield {
                "event": "update",
                "data": json.dumps(data)
            }
            
            counter += 1
            await asyncio.sleep(1)  # Send event every second
    
    return EventSourceResponse(event_generator())

@app.get("/real-time-logs")
async def stream_logs():
    async def log_generator():
        log_file = "app.log"
        
        with open(log_file, "r") as file:
            # Send existing log content
            file.seek(0, 2)  # Go to end of file
            
            while True:
                line = file.readline()
                if line:
                    yield {
                        "event": "log",
                        "data": line.strip()
                    }
                else:
                    await asyncio.sleep(0.1)  # Wait for new log entries
    
    return EventSourceResponse(log_generator())</code></pre>
            </div>

            <h3>Streaming with Progress Updates</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>@app.post("/process-large-dataset")
async def process_large_dataset():
    async def process_with_progress():
        total_items = 10000
        processed = 0
        
        # Send initial status
        yield json.dumps({
            "status": "started",
            "total": total_items,
            "processed": 0,
            "progress": 0
        }) + "\n"
        
        for i in range(total_items):
            # Simulate processing
            await asyncio.sleep(0.001)
            processed += 1
            
            # Send progress updates every 100 items
            if processed % 100 == 0:
                progress = (processed / total_items) * 100
                yield json.dumps({
                    "status": "processing",
                    "total": total_items,
                    "processed": processed,
                    "progress": round(progress, 2)
                }) + "\n"
        
        # Send completion status
        yield json.dumps({
            "status": "completed",
            "total": total_items,
            "processed": processed,
            "progress": 100
        }) + "\n"
    
    return StreamingResponse(
        process_with_progress(),
        media_type="application/x-ndjson"
    )</code></pre>
            </div>

            <h3>Memory-Efficient File Upload Processing</h3>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="language-label">Python</span>
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
                </div>
                <pre><code>from fastapi import UploadFile, File

@app.post("/process-upload-stream")
async def process_upload_stream(file: UploadFile = File(...)):
    async def process_file_stream():
        line_count = 0
        
        # Process file line by line without loading into memory
        async for line in file:
            line_count += 1
            
            # Process line (e.g., parse CSV, validate data)
            processed_data = {
                "line_number": line_count,
                "content": line.decode().strip(),
                "length": len(line)
            }
            
            yield json.dumps(processed_data) + "\n"
            
            # Send progress every 1000 lines
            if line_count % 1000 == 0:
                progress_data = {
                    "status": "processing",
                    "lines_processed": line_count
                }
                yield json.dumps(progress_data) + "\n"
    
    return StreamingResponse(
        process_file_stream(),
        media_type="application/x-ndjson"
    )</code></pre>
            </div>

            <div class="highlight">
                <p><strong>💡 Key Benefits of Streaming:</strong></p>
                <ul>
                    <li><strong>Memory Efficiency:</strong> Process large datasets without loading everything into memory</li>
                    <li><strong>Real-time Updates:</strong> Send data as it becomes available</li>
                    <li><strong>Better User Experience:</strong> Users see progress instead of waiting for completion</li>
                    <li><strong>Scalability:</strong> Handle multiple concurrent requests efficiently</li>
                </ul>
            </div>

            <div class="info">
                <p><strong>🔧 Best Practices:</strong></p>
                <ul>
                    <li>Use appropriate chunk sizes for optimal performance</li>
                    <li>Handle client disconnections gracefully</li>
                    <li>Set proper headers for content type and disposition</li>
                    <li>Consider using async generators for CPU-intensive operations</li>
                    <li>Monitor memory usage and implement backpressure when needed</li>
                </ul>
            </div>
        </section>        <div class="footer">
            <p>🚀 <strong>FastAPI Miscellaneous Topics Guide</strong> - Advanced concepts and utilities for modern web API development</p>
            <p>Created with ❤️ for developers building high-performance APIs</p>
        </div>
    </div>

    <script>
        // Sidebar functionality
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        function toggleSection(element) {
            const section = element.parentElement;
            const isActive = section.classList.contains('active');
            
            // Close all sections
            document.querySelectorAll('.sidebar-section').forEach(sec => {
                sec.classList.remove('active');
                const arrow = sec.querySelector('.sidebar-section-title span');
                if (arrow) arrow.textContent = '▶';
            });
            
            // Open clicked section if it wasn't active
            if (!isActive) {
                section.classList.add('active');
                const arrow = element.querySelector('span');
                if (arrow) arrow.textContent = '▼';
            }
        }        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            
            if (window.innerWidth <= 768 && 
                !sidebar.contains(event.target) && 
                !sidebarToggle.contains(event.target)) {
                sidebar.classList.remove('active');
            }
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
                
                // Update active link
                document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                link.classList.add('active');
            });
        });

        // Update active navigation on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('[id]');
            const navLinks = document.querySelectorAll('.nav-link');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href').substring(1) === current) {
                    link.classList.add('active');
                }
            });
        });

        // Progress bar functionality (if exists)
        function updateProgressBar() {
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                const scrollTop = window.pageYOffset;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = (scrollTop / docHeight) * 100;
                progressBar.style.width = scrollPercent + '%';
            }
        }

        window.addEventListener('scroll', updateProgressBar);
        updateProgressBar(); // Initial call

        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(function() {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#2ea043';
                
                setTimeout(function() {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#238636';
                }, 2000);
            }).catch(function(err) {
                console.error('Could not copy text: ', err);
                
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.backgroundColor = '#2ea043';
                
                setTimeout(function() {
                    button.textContent = originalText;
                    button.style.backgroundColor = '#238636';
                }, 2000);
            });
        }

        // Smooth scrolling for all links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const headerOffset = 120; // Account for sticky nav
                    const elementPosition = target.offsetTop;
                    const offsetPosition = elementPosition - headerOffset;
                    
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
    </div> <!-- End main-content -->
</body>
</html>
