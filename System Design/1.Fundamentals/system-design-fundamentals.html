<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèóÔ∏è System Design Fundamentals Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #e8e8e8;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
        }

        .sidebar {
            width: 280px;
            background: #1e1e1e;
            color: white;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            overflow-y: auto;
            z-index: 1000;
            transition: transform 0.3s ease;
            border-right: 1px solid #333;
        }

        .sidebar-header {
            padding: 20px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
        }

        .sidebar-header h2 {
            margin: 0;
            font-size: 1.3em;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #f0f0f0;
            border: none;
            padding: 0;
        }

        .sidebar-nav {
            padding: 0;
        }

        .sidebar-link {
            display: block;
            color: #b8b8b8;
            text-decoration: none;
            padding: 15px 20px;
            border-bottom: 1px solid #444;
            transition: background 0.2s ease;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.1em;
            font-weight: 500;
        }

        .sidebar-link:hover {
            background: #3a3a3a;
            color: #f0f0f0;
        }

        .sidebar-link.current {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: #3498db;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }

        .main-content {
            margin-left: 280px;
            flex: 1;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
        }

        h1 {
            color: #f0f0f0;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            font-size: 2.5em;
            margin-bottom: 30px;
        }

        h2 {
            color: #e0e0e0;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
            font-size: 1.8em;
        }

        h3 {
            color: #3498db;
            margin-top: 25px;
            font-size: 1.4em;
        }

        h4 {
            color: #5dade2;
            margin-top: 20px;
            font-size: 1.2em;
        }

        .toc {
            background: rgba(52, 152, 219, 0.15);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(52, 152, 219, 0.3);
        }

        .toc ul {
            list-style-type: none;
            padding-left: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: space-evenly;
            align-items: center;
            gap: 0.5rem;
        }

        .toc li {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 0 1 calc(16% - 0.5rem);
            min-width: 120px;
        }

        .toc a {
            color: #e0e0e0;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            background: rgba(50, 50, 50, 0.7);
            border: 1px solid rgba(52, 152, 219, 0.3);
            min-height: 40px;
            width: 100%;
        }

        .toc a:hover, .toc a.active {
            background: linear-gradient(45deg, #3498db, #5dade2);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        pre {
            background: #000000;
            color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        code {
            background: #000000;
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #ffffff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #2a2a2a;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        th, td {
            border: 1px solid #444;
            padding: 12px;
            text-align: left;
            color: #e0e0e0;
        }

        th {
            background: #3498db;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background: #333;
        }

        tr:hover {
            background: #404040;
        }

        .overview {
            background: #2a2a3a;
            border: 1px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #e0e0f0;
        }

        .fundamentals {
            background: #1a3a2a;
            border: 1px solid #27ae60;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #90ee90;
        }

        .architecture {
            background: #1a2a3a;
            border: 1px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #a8c8f0;
        }

        .tradeoffs {
            background: #3a1a1a;
            border: 1px solid #e74c3c;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #ffb3b3;
        }

        .patterns {
            background: #3a2a1a;
            border: 1px solid #f39c12;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #ffc966;
        }

        .performance {
            background: #2a1a3a;
            border: 1px solid #9b59b6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #d1a3ff;
        }

        .example {
            background: #2a2a2a;
            border-left: 4px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #e0e0e0;
        }

        .example h5 {
            margin-top: 0;
            color: #17a2b8;
            font-size: 1.1em;
        }

        .benefits {
            background: #1a3a1a;
            border: 1px solid #3498db;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #90ee90;
        }

        .benefits ul {
            margin: 10px 0;
        }

        .benefits li {
            margin: 5px 0;
        }

        .warning {
            background: #3a2f1a;
            border: 1px solid #b8860b;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #ffd700;
        }

        .warning::before {
            content: "‚ö†Ô∏è ";
            font-weight: bold;
            font-size: 1.2em;
        }

        .tip {
            background: #1a3a2f;
            border: 1px solid #27ae60;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            color: #7bed9f;
        }

        .tip::before {
            content: "üí° ";
            font-weight: bold;
            font-size: 1.2em;
        }

        @media (max-width: 1024px) {
            .toc ul {
                justify-content: center;
                gap: 0.75rem;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.active {
                transform: translateX(0);
            }

            .sidebar-toggle {
                display: block;
            }

            .main-content {
                margin-left: 0;
                padding: 15px;
            }

            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            table {
                font-size: 0.9em;
            }

            .toc {
                position: static;
                margin: 20px 0;
            }

            .toc ul {
                flex-direction: column;
                align-items: stretch;
                gap: 0.3rem;
            }

            .toc li {
                flex: 1;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" onclick="toggleSidebar()">‚ò∞</button>
    
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h2><a href="../system-design.html" style="color: inherit; text-decoration: none;">üóÇÔ∏è System Design</a></h2>
        </div>
        <nav class="sidebar-nav">
            <a href="../1.Fundamentals/system-design-fundamentals.html" class="sidebar-link current">
                üèóÔ∏è Fundamentals
            </a>
            <a href="../2.Networking & Communication/networking-communication.html" class="sidebar-link">
                üåê Networking & Communication
            </a>
            <a href="../3.Databases/databases.html" class="sidebar-link">
                üóÉÔ∏è Databases
            </a>
            <a href="../4.Caching/caching.html" class="sidebar-link">
                üóÑÔ∏è Caching
            </a>
            <a href="../5.Message Queues & Event-Driven Systems/message-queues-event-driven.html" class="sidebar-link">
                üì¨ Message Queues & Events
            </a>
            <a href="../6.Storage Systems/storage-systems.html" class="sidebar-link">
                üíæ Storage Systems
            </a>
            <a href="../7.Design Patterns & Architecture/design-patterns-architecture.html" class="sidebar-link">
                üèõÔ∏è Design Patterns
            </a>
            <a href="../8.Scalability & Performance/scalability-performance.html" class="sidebar-link">
                üìà Scalability & Performance
            </a>
            <a href="../9.Security in System Design/security-system-design.html" class="sidebar-link">
                üîí Security
            </a>
            <a href="../10.Monitoring & Observability/monitoring-observability.html" class="sidebar-link">
                üìä Monitoring & Observability
            </a>
            <a href="../11.Deployment & DevOps/deployment-devops.html" class="sidebar-link">
                üöÄ Deployment & DevOps
            </a>
            <a href="../12.Popular Use Cases/popular-use-cases.html" class="sidebar-link">
                üéØ Popular Use Cases
            </a>
            <a href="../13.Trade-offs & Decision Making/trade-offs-decision-making.html" class="sidebar-link">
                ‚öñÔ∏è Trade-offs & Decisions
            </a>
        </nav>
    </div>

    <div class="main-content">
        <div class="container">
            <h1>üèóÔ∏è System Design Fundamentals</h1>
            
            <div class="toc" id="toc">
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#client-server">Client-Server</a></li>
                    <li><a href="#apis-rpc">APIs & RPC</a></li>
                    <li><a href="#communication">Communication</a></li>
                    <li><a href="#scalability">Scalability</a></li>
                    <li><a href="#performance">Performance</a></li>
                    <li><a href="#reliability">Reliability</a></li>
                    <li><a href="#consistency">Consistency</a></li>
                    <li><a href="#load-balancing">Load Balancing</a></li>
                    <li><a href="#caching">Caching</a></li>
                    <li><a href="#partitioning">Partitioning</a></li>
                    <li><a href="#cap-theorem">CAP Theorem</a></li>
                </ul>
            </div>

            <h2 id="overview">Overview</h2>
            <div class="overview">
                <p>System design fundamentals provide the essential building blocks for creating scalable, reliable, and efficient distributed systems. These concepts form the foundation that every system architect and engineer must master to design systems that can handle real-world challenges.</p>
                
                <p>Understanding these fundamentals enables you to make informed architectural decisions, anticipate system bottlenecks, and design solutions that can grow with your needs while maintaining performance and reliability.</p>
            </div>

            <h2 id="client-server">üèóÔ∏è Client-Server Architecture</h2>
            <p>The fundamental architectural pattern where clients (users/applications) request services from servers (systems that provide resources or services). This model forms the basis of most distributed systems and web applications.</p>

            <div class="architecture">
                <h3>Core Characteristics</h3>
                <ul>
                    <li><strong>Request-Response Pattern:</strong> Clients initiate communication by sending requests</li>
                    <li><strong>Service Distribution:</strong> Servers provide specialized services or resources</li>
                    <li><strong>Separation of Concerns:</strong> Clear division between client and server responsibilities</li>
                    <li><strong>Centralized Management:</strong> Servers can manage shared resources and state</li>
                </ul>
            </div>

            <h3>Architecture Types</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Description</th>
                    <th>Examples</th>
                    <th>Use Cases</th>
                </tr>
                <tr><td><strong>Two-Tier</strong></td><td>Client directly communicates with database server</td><td>Desktop applications</td><td>Small applications, simple CRUD</td></tr>
                <tr><td><strong>Three-Tier</strong></td><td>Client, application server, database server</td><td>Web applications</td><td>Most modern web apps</td></tr>
                <tr><td><strong>Multi-Tier</strong></td><td>Multiple layers of servers and services</td><td>Enterprise applications</td><td>Complex business systems</td></tr>
                <tr><td><strong>Microservices</strong></td><td>Multiple small, independent services</td><td>Netflix, Amazon</td><td>Large-scale distributed systems</td></tr>
            </table>

            <div class="example">
                <h5>Client-Server Communication Flow:</h5>
                <pre><code>1. Client sends HTTP request to server
   GET /api/users/123 HTTP/1.1
   Host: example.com

2. Server processes request
   - Authenticate user
   - Validate permissions
   - Query database
   - Format response

3. Server sends response to client
   HTTP/1.1 200 OK
   Content-Type: application/json
   
   {"id": 123, "name": "John Doe", "email": "john@example.com"}

4. Client processes response
   - Parse JSON data
   - Update user interface
   - Handle errors if any</code></pre>
            </div>

            <h2 id="apis-rpc">üîå RESTful APIs and RPC</h2>
            <p>Two primary approaches for communication between distributed components, each with distinct characteristics and use cases.</p>

            <h3>RESTful APIs</h3>
            <div class="architecture">
                <p><strong>REST (Representational State Transfer)</strong> is an architectural style that uses HTTP methods and stateless communication, emphasizing resource-based interactions.</p>
                
                <h4>REST Principles:</h4>
                <ul>
                    <li><strong>Stateless:</strong> Each request contains all necessary information</li>
                    <li><strong>Resource-Based:</strong> URLs represent resources, not actions</li>
                    <li><strong>HTTP Methods:</strong> GET, POST, PUT, DELETE for different operations</li>
                    <li><strong>Cacheable:</strong> Responses can be cached for performance</li>
                    <li><strong>Uniform Interface:</strong> Consistent way to interact with resources</li>
                </ul>
            </div>

            <h3>RPC (Remote Procedure Call)</h3>
            <div class="architecture">
                <p><strong>RPC</strong> allows programs to execute procedures on remote systems by abstracting network communication to make remote function calls appear as local function calls.</p>
                
                <h4>RPC Characteristics:</h4>
                <ul>
                    <li><strong>Action-Based:</strong> Focuses on actions/procedures to execute</li>
                    <li><strong>Tight Coupling:</strong> Client and server must agree on interface</li>
                    <li><strong>Efficient:</strong> Often uses binary protocols for performance</li>
                    <li><strong>Type Safety:</strong> Strong typing and code generation</li>
                </ul>
            </div>

            <h3>REST vs RPC Comparison</h3>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>REST</th>
                    <th>RPC</th>
                </tr>
                <tr><td><strong>Design Philosophy</strong></td><td>Resource-oriented</td><td>Action-oriented</td></tr>
                <tr><td><strong>Protocol</strong></td><td>Usually HTTP</td><td>HTTP, TCP, or custom protocols</td></tr>
                <tr><td><strong>Coupling</strong></td><td>Loose coupling</td><td>Tight coupling</td></tr>
                <tr><td><strong>Caching</strong></td><td>Built-in HTTP caching</td><td>Custom caching solutions</td></tr>
                <tr><td><strong>Debugging</strong></td><td>Easy with standard tools</td><td>Requires specialized tools</td></tr>
                <tr><td><strong>Performance</strong></td><td>Good for web applications</td><td>Better for high-performance scenarios</td></tr>
            </table>

            <h2 id="communication">‚ö° Synchronous vs Asynchronous Communication</h2>
            <p>Different patterns for how components interact, each with specific trade-offs in terms of performance, complexity, and system coupling.</p>

            <h3>Synchronous Communication</h3>
            <div class="patterns">
                <p><strong>Blocking communication</strong> where the caller waits for a response before continuing execution.</p>
                
                <h4>Characteristics:</h4>
                <ul>
                    <li><strong>Blocking:</strong> Caller thread is blocked until response arrives</li>
                    <li><strong>Immediate Response:</strong> Results are available immediately</li>
                    <li><strong>Simple Error Handling:</strong> Errors are returned directly</li>
                    <li><strong>Temporal Coupling:</strong> Components must be available simultaneously</li>
                </ul>
            </div>

            <h3>Asynchronous Communication</h3>
            <div class="patterns">
                <p><strong>Non-blocking communication</strong> allowing parallel processing and loose coupling between components.</p>
                
                <h4>Characteristics:</h4>
                <ul>
                    <li><strong>Non-Blocking:</strong> Caller continues execution immediately</li>
                    <li><strong>Eventual Response:</strong> Results delivered via callbacks or events</li>
                    <li><strong>Complex Error Handling:</strong> Errors handled asynchronously</li>
                    <li><strong>Loose Coupling:</strong> Components can operate independently</li>
                </ul>
            </div>

            <h3>Communication Patterns</h3>
            <table>
                <tr>
                    <th>Pattern</th>
                    <th>Type</th>
                    <th>Use Case</th>
                    <th>Example</th>
                </tr>
                <tr><td><strong>Request-Response</strong></td><td>Synchronous</td><td>Web APIs, database queries</td><td>HTTP REST calls</td></tr>
                <tr><td><strong>Message Queue</strong></td><td>Asynchronous</td><td>Background processing</td><td>Email sending, file processing</td></tr>
                <tr><td><strong>Event Streaming</strong></td><td>Asynchronous</td><td>Real-time updates</td><td>Stock price updates</td></tr>
                <tr><td><strong>Pub/Sub</strong></td><td>Asynchronous</td><td>Notification systems</td><td>News feed updates</td></tr>
            </table>

            <h2 id="scalability">üìà Scalability: Horizontal vs Vertical</h2>
            <p>Approaches to handle increasing system load, each with different characteristics, costs, and complexity implications.</p>

            <h3>Vertical Scaling (Scale Up)</h3>
            <div class="performance">
                <p><strong>Adding more power to existing machines</strong> - increasing CPU, RAM, or storage on current servers.</p>
                
                <h4>Advantages:</h4>
                <ul>
                    <li><strong>Simple Implementation:</strong> No architectural changes needed</li>
                    <li><strong>No Distributed Complexity:</strong> Single machine eliminates coordination issues</li>
                    <li><strong>Strong Consistency:</strong> All data in one place</li>
                    <li><strong>Familiar Tools:</strong> Standard monitoring and debugging</li>
                </ul>
                
                <h4>Disadvantages:</h4>
                <ul>
                    <li><strong>Hardware Limits:</strong> Physical constraints on maximum capacity</li>
                    <li><strong>Single Point of Failure:</strong> If machine fails, entire system goes down</li>
                    <li><strong>Expensive:</strong> High-end hardware costs grow exponentially</li>
                    <li><strong>Downtime:</strong> Upgrades often require system shutdown</li>
                </ul>
            </div>

            <h3>Horizontal Scaling (Scale Out)</h3>
            <div class="performance">
                <p><strong>Adding more machines</strong> to distribute load across multiple servers.</p>
                
                <h4>Advantages:</h4>
                <ul>
                    <li><strong>Unlimited Growth:</strong> Theoretically unlimited scaling capacity</li>
                    <li><strong>Fault Tolerance:</strong> Individual machine failures don't affect entire system</li>
                    <li><strong>Cost-Effective:</strong> Use commodity hardware</li>
                    <li><strong>Flexible:</strong> Can add/remove capacity as needed</li>
                </ul>
                
                <h4>Disadvantages:</h4>
                <ul>
                    <li><strong>Complexity:</strong> Distributed system challenges</li>
                    <li><strong>Consistency Issues:</strong> Data synchronization across machines</li>
                    <li><strong>Network Overhead:</strong> Communication between machines</li>
                    <li><strong>Coordination:</strong> Load balancing and service discovery</li>
                </ul>
            </div>

            <h2 id="performance">‚è±Ô∏è Throughput vs Latency</h2>
            <p>Critical performance metrics that often require trade-offs, based on queuing theory and system optimization principles.</p>

            <h3>Understanding the Metrics</h3>
            <div class="performance">
                <ul>
                    <li><strong>Throughput:</strong> Number of requests processed per unit time (requests/second)</li>
                    <li><strong>Latency:</strong> Time taken to process a single request (milliseconds)</li>
                    <li><strong>Response Time:</strong> Total time from request to response (includes network time)</li>
                    <li><strong>Bandwidth:</strong> Maximum data transfer rate (MB/s)</li>
                </ul>
            </div>

            <h3>Trade-offs and Optimization</h3>
            <table>
                <tr>
                    <th>Optimization Goal</th>
                    <th>Techniques</th>
                    <th>Trade-offs</th>
                    <th>Use Cases</th>
                </tr>
                <tr><td><strong>Low Latency</strong></td><td>Caching, CDNs, local processing</td><td>Higher resource usage, cost</td><td>Trading systems, gaming</td></tr>
                <tr><td><strong>High Throughput</strong></td><td>Batching, queuing, parallel processing</td><td>Higher latency, complexity</td><td>Data processing, analytics</td></tr>
                <tr><td><strong>Balanced</strong></td><td>Load balancing, connection pooling</td><td>Moderate complexity</td><td>Web applications</td></tr>
            </table>

            <div class="example">
                <h5>Performance Optimization Example:</h5>
                <pre><code>// Low Latency Approach (individual processing)
async function processRequest(request) {
    const result = await processImmediately(request);
    return result; // ~10ms latency, 100 requests/second
}

// High Throughput Approach (batch processing)
async function processBatch(requests) {
    const results = await processBatchEfficiently(requests);
    return results; // ~100ms latency, 1000 requests/second
}</code></pre>
            </div>

            <h2 id="reliability">üõ°Ô∏è Availability, Reliability, and Fault Tolerance</h2>
            <p>Core system qualities that ensure consistent service delivery through various failure scenarios.</p>

            <h3>Key Concepts</h3>
            <div class="fundamentals">
                <ul>
                    <li><strong>Availability:</strong> System uptime percentage (99.9% = 8.76 hours downtime/year)</li>
                    <li><strong>Reliability:</strong> Consistent performance over time without failures</li>
                    <li><strong>Fault Tolerance:</strong> System's ability to continue operating despite failures</li>
                    <li><strong>Resilience:</strong> Ability to recover quickly from failures</li>
                </ul>
            </div>

            <h3>Availability Levels</h3>
            <table>
                <tr>
                    <th>Availability</th>
                    <th>Downtime/Year</th>
                    <th>Downtime/Month</th>
                    <th>Use Case</th>
                </tr>
                <tr><td><strong>99% (2 nines)</strong></td><td>3.65 days</td><td>7.31 hours</td><td>Internal tools</td></tr>
                <tr><td><strong>99.9% (3 nines)</strong></td><td>8.77 hours</td><td>43.83 minutes</td><td>Small websites</td></tr>
                <tr><td><strong>99.99% (4 nines)</strong></td><td>52.60 minutes</td><td>4.38 minutes</td><td>Business applications</td></tr>
                <tr><td><strong>99.999% (5 nines)</strong></td><td>5.26 minutes</td><td>26.30 seconds</td><td>Critical systems</td></tr>
            </table>

            <h3>Fault Tolerance Patterns</h3>
            <div class="patterns">
                <h4>Common Patterns:</h4>
                <ul>
                    <li><strong>Redundancy:</strong> Multiple copies of critical components</li>
                    <li><strong>Circuit Breakers:</strong> Prevent cascading failures</li>
                    <li><strong>Graceful Degradation:</strong> Reduced functionality instead of total failure</li>
                    <li><strong>Bulkheads:</strong> Isolate failures to prevent system-wide impact</li>
                    <li><strong>Retry Logic:</strong> Automatic retries with exponential backoff</li>
                </ul>
            </div>

            <h2 id="consistency">üîÑ Consistency Models</h2>
            <p>Different approaches to data consistency in distributed systems, addressing the fundamental challenge of maintaining data coherence across multiple nodes.</p>

            <h3>Strong Consistency</h3>
            <div class="architecture">
                <p><strong>All nodes see the same data simultaneously</strong> - ensures immediate consistency at the cost of availability and performance.</p>
                
                <h4>Characteristics:</h4>
                <ul>
                    <li><strong>Immediate Consistency:</strong> All reads return the most recent write</li>
                    <li><strong>Synchronous Updates:</strong> All replicas updated before confirming write</li>
                    <li><strong>Higher Latency:</strong> Network coordination overhead</li>
                    <li><strong>Potential Unavailability:</strong> System may block during network partitions</li>
                </ul>
            </div>

            <h3>Eventual Consistency</h3>
            <div class="architecture">
                <p><strong>System becomes consistent over time</strong> - allows temporary inconsistencies for better availability and performance.</p>
                
                <h4>Characteristics:</h4>
                <ul>
                    <li><strong>Asynchronous Updates:</strong> Replicas updated independently</li>
                    <li><strong>Temporary Inconsistency:</strong> Different nodes may have different values</li>
                    <li><strong>Better Availability:</strong> System remains operational during network issues</li>
                    <li><strong>Conflict Resolution:</strong> Mechanisms to resolve conflicting updates</li>
                </ul>
            </div>

            <h3>Causal Consistency</h3>
            <div class="architecture">
                <p><strong>Causally related operations seen in same order</strong> - preserves logical ordering while allowing concurrent operations to vary.</p>
                
                <h4>Characteristics:</h4>
                <ul>
                    <li><strong>Causal Ordering:</strong> Dependent operations maintain order</li>
                    <li><strong>Concurrent Freedom:</strong> Independent operations can reorder</li>
                    <li><strong>Moderate Complexity:</strong> More complex than eventual, simpler than strong</li>
                    <li><strong>Real-world Applications:</strong> Social media feeds, collaborative editing</li>
                </ul>
            </div>

            <h3>Consistency Model Use Cases</h3>
            <table>
                <tr>
                    <th>Consistency Model</th>
                    <th>Use Cases</th>
                    <th>Examples</th>
                    <th>Trade-offs</th>
                </tr>
                <tr><td><strong>Strong</strong></td><td>Financial systems, inventory management</td><td>Banking, e-commerce stock</td><td>Lower availability, higher latency</td></tr>
                <tr><td><strong>Eventual</strong></td><td>Social media, content distribution</td><td>Facebook feeds, DNS</td><td>Temporary inconsistency</td></tr>
                <tr><td><strong>Causal</strong></td><td>Collaborative tools, messaging</td><td>Google Docs, chat systems</td><td>Moderate complexity</td></tr>
            </table>

            <h2 id="load-balancing">‚öñÔ∏è Load Balancing</h2>
            <p>Distributing incoming requests across multiple servers to optimize resource utilization and prevent bottlenecks.</p>

            <h3>Load Balancing Algorithms</h3>
            <div class="patterns">
                <ul>
                    <li><strong>Round Robin:</strong> Distribute requests sequentially across servers</li>
                    <li><strong>Least Connections:</strong> Route to server with fewest active connections</li>
                    <li><strong>Weighted:</strong> Assign different weights based on server capacity</li>
                    <li><strong>IP Hash:</strong> Route based on client IP hash for session affinity</li>
                    <li><strong>Health-Based:</strong> Consider server health metrics in routing decisions</li>
                </ul>
            </div>

            <h3>Load Balancer Types</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Layer</th>
                    <th>Routing Basis</th>
                    <th>Performance</th>
                    <th>Features</th>
                </tr>
                <tr><td><strong>Layer 4 (Transport)</strong></td><td>TCP/UDP</td><td>IP address, port</td><td>Very fast</td><td>Simple, low latency</td></tr>
                <tr><td><strong>Layer 7 (Application)</strong></td><td>HTTP</td><td>URL, headers, content</td><td>Moderate</td><td>Advanced routing, SSL termination</td></tr>
                <tr><td><strong>Hardware</strong></td><td>Various</td><td>Configurable</td><td>Highest</td><td>Dedicated hardware, expensive</td></tr>
                <tr><td><strong>Software</strong></td><td>Various</td><td>Configurable</td><td>Good</td><td>Flexible, cost-effective</td></tr>
            </table>

            <div class="example">
                <h5>Load Balancer Configuration Example:</h5>
                <pre><code>// Simple Round Robin Load Balancer
class LoadBalancer {
    constructor(servers) {
        this.servers = servers;
        this.currentIndex = 0;
    }
    
    getNextServer() {
        const server = this.servers[this.currentIndex];
        this.currentIndex = (this.currentIndex + 1) % this.servers.length;
        return server;
    }
    
    routeRequest(request) {
        const server = this.getNextServer();
        return server.handle(request);
    }
}</code></pre>
            </div>

            <h2 id="caching">üóÑÔ∏è Caching Strategies</h2>
            <p>Storing frequently accessed data in fast storage for quick retrieval, based on locality principles where recently accessed data is likely to be accessed again.</p>

            <h3>Caching Levels</h3>
            <div class="performance">
                <ul>
                    <li><strong>Browser Cache:</strong> Client-side caching for static assets</li>
                    <li><strong>CDN Cache:</strong> Geographic distribution of content</li>
                    <li><strong>Reverse Proxy Cache:</strong> Server-side caching layer</li>
                    <li><strong>Application Cache:</strong> In-memory caching within application</li>
                    <li><strong>Database Cache:</strong> Query result caching</li>
                </ul>
            </div>

            <h3>Cache Patterns</h3>
            <table>
                <tr>
                    <th>Pattern</th>
                    <th>Description</th>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                <tr><td><strong>Cache-Aside</strong></td><td>Application manages cache explicitly</td><td>Flexible, only caches what's needed</td><td>Cache misses require extra work</td></tr>
                <tr><td><strong>Write-Through</strong></td><td>Write to cache and database simultaneously</td><td>Data consistency, no data loss</td><td>Higher write latency</td></tr>
                <tr><td><strong>Write-Behind</strong></td><td>Write to cache first, database later</td><td>Low write latency</td><td>Risk of data loss</td></tr>
                <tr><td><strong>Refresh-Ahead</strong></td><td>Proactively refresh cache before expiration</td><td>Reduced latency</td><td>Increased complexity</td></tr>
            </table>

            <h3>Cache Invalidation Strategies</h3>
            <div class="patterns">
                <ul>
                    <li><strong>TTL (Time to Live):</strong> Automatic expiration after fixed time</li>
                    <li><strong>Event-Based:</strong> Invalidate when underlying data changes</li>
                    <li><strong>Manual:</strong> Explicit cache clearing by application</li>
                    <li><strong>LRU (Least Recently Used):</strong> Remove least recently used items</li>
                </ul>
            </div>

            <h2 id="partitioning">üîÄ Data Partitioning and Sharding</h2>
            <p>Techniques for distributing data across multiple databases or servers to overcome single-machine limitations.</p>

            <h3>Partitioning Types</h3>
            <div class="architecture">
                <ul>
                    <li><strong>Horizontal Partitioning (Sharding):</strong> Split rows across databases</li>
                    <li><strong>Vertical Partitioning:</strong> Split columns across databases</li>
                    <li><strong>Functional Partitioning:</strong> Split by feature or service</li>
                    <li><strong>Directory-Based:</strong> Use lookup service for data location</li>
                </ul>
            </div>

            <h3>Sharding Strategies</h3>
            <table>
                <tr>
                    <th>Strategy</th>
                    <th>Method</th>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                <tr><td><strong>Range-Based</strong></td><td>Partition by data ranges</td><td>Range queries efficient</td><td>Hot spots possible</td></tr>
                <tr><td><strong>Hash-Based</strong></td><td>Hash function determines shard</td><td>Even distribution</td><td>Range queries difficult</td></tr>
                <tr><td><strong>Directory-Based</strong></td><td>Lookup service for routing</td><td>Flexible, easy to rebalance</td><td>Single point of failure</td></tr>
                <tr><td><strong>Consistent Hashing</strong></td><td>Hash ring with virtual nodes</td><td>Minimal data movement</td><td>Complex implementation</td></tr>
            </table>

            <div class="example">
                <h5>Hash-Based Sharding Example:</h5>
                <pre><code>// Simple Hash-Based Sharding
class ShardManager {
    constructor(shards) {
        this.shards = shards;
        this.shardCount = shards.length;
    }
    
    getShardForKey(key) {
        const hash = this.simpleHash(key);
        return this.shards[hash % this.shardCount];
    }
    
    simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
    }
}</code></pre>
            </div>

            <h2 id="cap-theorem">‚ö° CAP Theorem</h2>
            <p>Fundamental principle stating that distributed systems can only guarantee two of three properties simultaneously.</p>

            <h3>CAP Properties</h3>
            <div class="tradeoffs">
                <ul>
                    <li><strong>Consistency:</strong> All nodes see the same data at the same time</li>
                    <li><strong>Availability:</strong> System remains operational and responsive</li>
                    <li><strong>Partition Tolerance:</strong> System continues despite network failures</li>
                </ul>
            </div>

            <h3>CAP Combinations</h3>
            <table>
                <tr>
                    <th>Combination</th>
                    <th>Description</th>
                    <th>Examples</th>
                    <th>Trade-offs</th>
                </tr>
                <tr><td><strong>CP (Consistency + Partition Tolerance)</strong></td><td>Sacrifice availability for consistency</td><td>MongoDB, Redis</td><td>System may become unavailable</td></tr>
                <tr><td><strong>AP (Availability + Partition Tolerance)</strong></td><td>Sacrifice consistency for availability</td><td>Cassandra, DynamoDB</td><td>Temporary data inconsistency</td></tr>
                <tr><td><strong>CA (Consistency + Availability)</strong></td><td>Sacrifice partition tolerance</td><td>Traditional RDBMS</td><td>Cannot handle network partitions</td></tr>
            </table>

            <div class="warning">
                <strong>Important:</strong> In practice, network partitions are inevitable in distributed systems, so the choice is usually between CP and AP systems. CA systems are typically single-node systems that don't truly distribute data.
            </div>

            <h3>Real-World CAP Decisions</h3>
            <div class="tradeoffs">
                <ul>
                    <li><strong>Banking Systems:</strong> Choose CP - consistency is critical for financial data</li>
                    <li><strong>Social Media:</strong> Choose AP - availability is more important than perfect consistency</li>
                    <li><strong>DNS:</strong> Choose AP - availability is crucial for internet functionality</li>
                    <li><strong>Inventory Systems:</strong> Choose CP - avoid overselling products</li>
                </ul>
            </div>

            <h2>Best Practices</h2>

            <h3>Design Principles</h3>
            <div class="tip">
                <ul>
                    <li><strong>Start Simple:</strong> Begin with simple architectures and add complexity as needed</li>
                    <li><strong>Understand Trade-offs:</strong> Every design decision involves trade-offs</li>
                    <li><strong>Plan for Failure:</strong> Assume components will fail and design accordingly</li>
                    <li><strong>Measure Everything:</strong> Monitor performance and behavior continuously</li>
                    <li><strong>Document Decisions:</strong> Record architectural decisions and rationale</li>
                </ul>
            </div>

            <h3>Common Pitfalls to Avoid</h3>
            <div class="warning">
                <ul>
                    <li><strong>Over-engineering:</strong> Adding unnecessary complexity from the start</li>
                    <li><strong>Ignoring CAP:</strong> Not considering consistency/availability trade-offs</li>
                    <li><strong>Poor Monitoring:</strong> Insufficient visibility into system behavior</li>
                    <li><strong>Premature Optimization:</strong> Optimizing before understanding bottlenecks</li>
                    <li><strong>Single Points of Failure:</strong> Not considering fault tolerance</li>
                </ul>
            </div>

            <h2>Summary</h2>
            <div class="benefits">
                <p>System design fundamentals provide the foundation for building scalable, reliable, and efficient distributed systems. Understanding these concepts enables you to:</p>
                
                <ul>
                    <li><strong>Make Informed Decisions:</strong> Choose appropriate architectural patterns</li>
                    <li><strong>Understand Trade-offs:</strong> Balance performance, consistency, and availability</li>
                    <li><strong>Design for Scale:</strong> Build systems that can grow with demand</li>
                    <li><strong>Plan for Failure:</strong> Create resilient systems that handle failures gracefully</li>
                    <li><strong>Optimize Performance:</strong> Improve throughput and reduce latency</li>
                </ul>
            </div>

            <h3>Next Steps</h3>
            <p>After mastering these fundamentals, explore specific areas in detail:</p>
            <ul>
                <li><strong>Networking & Communication:</strong> Deep dive into protocols and communication patterns</li>
                <li><strong>Databases:</strong> Learn about database design and distributed data systems</li>
                <li><strong>Caching:</strong> Advanced caching strategies and implementations</li>
                <li><strong>Scalability & Performance:</strong> Performance optimization techniques</li>
            </ul>

            <p style="text-align: center; font-size: 1.2em; color: #3498db; margin-top: 30px;">
                <strong>Master these fundamentals to build systems that can scale and thrive in the real world! üöÄ</strong>
            </p>
        </div>
    </div>

    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const toggle = document.querySelector('.sidebar-toggle');
            
            if (window.innerWidth <= 768 && 
                !sidebar.contains(event.target) && 
                !toggle.contains(event.target) && 
                sidebar.classList.contains('active')) {
                sidebar.classList.remove('active');
            }
        });

        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const tocElement = document.querySelector('.toc');
                    const tocHeight = tocElement ? tocElement.offsetHeight : 0;
                    const offset = tocHeight + 40;
                    
                    const targetPosition = target.offsetTop - offset;
                    
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                    
                    document.querySelectorAll('.toc a').forEach(link => {
                        link.classList.remove('active');
                    });
                    this.classList.add('active');
                }
            });
        });

        // Highlight current section in TOC on scroll
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('h2[id]');
            const tocLinks = document.querySelectorAll('.toc a');
            
            let current = '';
            const tocElement = document.querySelector('.toc');
            const tocHeight = tocElement ? tocElement.offsetHeight : 0;
            const offset = tocHeight + 50;
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.scrollY >= sectionTop - offset) {
                    current = section.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>